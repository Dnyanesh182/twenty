DESCRIPTION >
	Inspired by DUB implementation


NODE dayIntervals
SQL >

    %
        WITH
            toStartOfDay(
                toDateTime64({{ DateTime64(start, '2024-10-16 00:00:00.000') }}, 3),
                {{ String(timezone, 'UTC') }}
            ) AS start,
            toStartOfDay(
                toDateTime64({{ DateTime64(end, '2024-10-23 00:00:00.000') }}, 3),
                {{ String(timezone, 'UTC') }}
            ) AS
        end
        SELECT
            arrayJoin(
                arrayMap(
                    x -> toDateTime64(toStartOfDay(toDateTime64(x, 3), {{ String(timezone, 'UTC') }}), 3),
                    range(toUInt32(start + 86400), toUInt32(end + 86400),
                    86400
                )
            )
        ) as interval



NODE hourIntervals
SQL >

    %
    WITH
        toStartOfHour(
            toDateTime64({{ DateTime64(start, '2024-10-22 00:00:00.000') }}, 3),
            {{ String(timezone, 'UTC') }}
        ) AS start,
        toStartOfHour(
            toDateTime64({{ DateTime64(end, '2024-10-23 00:00:00.000') }}, 3),
            {{ String(timezone, 'UTC') }}
        ) AS
    end
    SELECT
        arrayJoin(
            arrayMap(x -> toDateTime64(x, 3), range(toUInt32(start + 3600), toUInt32(end + 3600), 3600)
        )
    ) as interval



NODE customIntervals
DESCRIPTION >
    Gives

SQL >

    %
    WITH
        time_series AS (
            SELECT
                toDateTime64(
                    toDateTime(toStartOfInterval(
                        toDateTime64({{ DateTime64(start, '2024-10-22 00:00:00.000') }}, 3),
                        INTERVAL {{ Int32(tickIntervalInMinutes, 420) }} MINUTE
                    ))
                    + INTERVAL number * {{ Int32(tickIntervalInMinutes, 420) }} MINUTE,
                    3
                ) AS interval
            FROM numbers(
                0,
                1 + intDiv(
                    dateDiff(
                        'minute',
                        toDateTime64({{ DateTime64(start, '2024-10-22 00:00:00.000') }}, 3),
                        toDateTime64({{ DateTime64(end, '2024-10-23 00:00:00.000') }}, 3)
                    ),
                    {{ Int32(tickIntervalInMinutes, 420) }}
                )
            )
            WHERE interval <= toDateTime64({{ DateTime64(end, '2024-10-23 00:00:00.000') }}, 3)
        )
    SELECT
        interval
    FROM time_series



NODE workspaceWebhooks
SQL >

    %
    SELECT webhookId
    from webhooksEventMV
    WHERE
        workspaceId
        = {{
            String(
                workspaceId,
                '20202020-1c25-4d02-bf25-6aeccf7ea419',
                description="The ID of the workspace",
                required=True,
            )
        }}



NODE workspaceServerlessFunctions
SQL >

    %
    SELECT functionId
    from serverlessFunctionsEventMV
    WHERE
        workspaceId
        = {{
            String(
                workspaceId,
                '20202020-1c25-4d02-bf25-6aeccf7ea419',
                description="The ID of the workspace",
                required=True,
            )
        }}



NODE timeSeriesWebhooksData
SQL >

    %

    SELECT
        {% if granularity == "hour" %} toStartOfHour(timestamp, {{ String(timezone, 'UTC') }})
        {% elif granularity == "custom" %}
            toDateTime64(
                toStartOfMinute(timestamp, {{ String(timezone, 'UTC') }}),
                3,
                {{ String(timezone, 'UTC') }}
            )
        {% else %} toDateTime64(toStartOfDay(timestamp, {{ String(timezone, 'UTC') }}), 3)
        {% end %} AS interval,
        uniqIf(*, success=true) as success_count,
        uniqIf(*, success=false) as failure_count
    FROM
        webhooksEventMV
        {% if not defined(webhookId) and defined(workspaceId) %}
            PREWHERE webhookId in (SELECT webhookId from workspaceWebhooks)
        {% end %}
    WHERE
        true
        {% if defined(webhookId) %} AND webhookId = {{ String(webhookId) }} {% end %}
        AND workspaceId={{ String(workspaceId) }}
        AND timestamp >= {{ DateTime(start, '2024-10-22 00:00:00') }}
        AND timestamp < {{ DateTime(end, '2024-10-23 00:00:00') }}
    GROUP BY interval
    ORDER BY interval



NODE timeSeriesWebhooks
SQL >

    %

    SELECT formatDateTime(interval, '%FT%T.000%z') as start, success_count, failure_count
    FROM
        {% if granularity == "custom" %} customIntervals
        {% elif granularity == "hour" %} hourIntervals
        {% else %} dayIntervals
        {% end %}
    LEFT JOIN timeSeriesWebhooksData USING interval



NODE timeSeriesServerlessFunctionsErrorsData
SQL >

    %
    SELECT
        {% if granularity == "hour" %} toStartOfHour(timestamp, {{ String(timezone, 'UTC') }})
        {% elif granularity == "custom" %}
            toDateTime64(
                toStartOfMinute(timestamp, {{ String(timezone, 'UTC') }}),
                3,
                {{ String(timezone, 'UTC') }}
            )
        {% else %} toDateTime64(toStartOfDay(timestamp, {{ String(timezone, 'UTC') }}), 3)
        {% end %} AS interval,
        uniqIf(*, success = false) as error_count,
        -- change it to div 0 val
        round(
            if(
                uniqIf(*, success = true) = 0,
                0,
                (uniqIf(*, success = true) - uniqIf(*, success = false)) / uniqIf(*, success = true)
            ),
            2
        ) as success_rate
    FROM
        serverlessFunctionsEventMV
        {% if not defined(functionId) and defined(workspaceId) %}
            PREWHERE functionId in (SELECT functionId from workspaceServerlessFunctions)
        {% end %}
    WHERE
        true
        {% if defined(functionId) %} AND functionId = {{ String(functionId) }} {% end %}
        AND workspaceId ={{ String(workspaceId) }}
        AND timestamp >= {{ DateTime(start, '2024-10-22 00:00:00') }}
        AND timestamp < {{ DateTime(end, '2024-10-23 00:00:00') }}
    GROUP BY interval
    ORDER BY interval



NODE timeSeriesServerlessFunctionsDurationData
SQL >

    %

    SELECT
        {% if granularity == "hour" %} toStartOfHour(timestamp, {{ String(timezone, 'UTC') }})
        {% elif granularity == "custom" %}
            toDateTime64(
                toStartOfMinute(timestamp, {{ String(timezone, 'UTC') }}),
                3,
                {{ String(timezone, 'UTC') }}
            )
        {% else %} toDateTime64(toStartOfDay(timestamp, {{ String(timezone, 'UTC') }}), 3)
        {% end %} AS interval,
        avg(CAST(durationInMs AS Float64)) as average,
        min(durationInMs) as minimum,
        max(durationInMs) as maximum
    FROM
        serverlessFunctionsEventMV
        {% if not defined(functionId) and defined(workspaceId) %}
            PREWHERE functionId in (SELECT functionId from workspaceServerlessFunctions)
        {% end %}
    WHERE
        true
        {% if defined(functionId) %} AND functionId = {{ String(functionId) }} {% end %}
        AND workspaceId ={{ String(workspaceId) }}
        AND timestamp >= {{ DateTime(start, '2024-10-22 00:00:00') }}
        AND timestamp < {{ DateTime(end, '2024-10-23 00:00:00') }}
    GROUP BY interval
    ORDER BY interval



NODE timeSeriesServerlessFunctionsDuration
SQL >

    %

    SELECT formatDateTime(interval, '%FT%T.000%z') as start, minimum, maximum, average
    FROM
        {% if granularity == "custom" %} customIntervals
        {% elif granularity == "hour" %} hourIntervals
        {% else %} dayIntervals
        {% end %}
    LEFT JOIN timeSeriesServerlessFunctionsDurationData USING interval



NODE timeSeriesServerlessFunctionsErrors
SQL >

    %

    SELECT formatDateTime(interval, '%FT%T.000%z') as start, error_count, success_rate
    FROM
        {% if granularity == "custom" %} customIntervals
        {% elif granularity == "hour" %} hourIntervals
        {% else %} dayIntervals
        {% end %}
    LEFT JOIN timeSeriesServerlessFunctionsErrorsData USING interval



NODE ENFIIIIIIIIIIN
SQL >

    %
        SELECT *
        FROM
            {% if eventType == 'webhooks' %} timeSeriesWebhooks
            {% elif eventType == 'serverlessFunctions.error' %} timeSeriesServerlessFunctionsErrors
            {% elif eventType == 'serverlessFunctions.duration' %} timeSeriesServerlessFunctionsDuration
            {% else %} event
            {% end %}


